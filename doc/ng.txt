*	regular grammars
**	A ->,  A->a, A->aB,  distinguished S symbol

* 	translating them to NDFAs

**	One state for each of the nonterminals

**	S for initial state, new state Z for final state

**	Each production of the form A->a generates an arc from A to Z, which consumes a

**	Each production of the form A->aB generates an arc from A to B, which consumes a

**	Each production of the form A-> generates an arc from A to Z, which doesn't consume anything.


*	Example Regular expressions and how to do them

**	.  Any single character

***	A->a1,  A->a2, ....  A->a1B, A->a2B, ....

***	Obvious fix:

***	A->., A->.B  Syntactic Sutar for the above.

***	NDFA gen:
****	For each production of the form A->., generate an arc from A to Z, which consumes any single terminal
****	For each production of the form A->.B, generate an arc from A to B, which consumes any single terminal


**	[abc],[a-z]  Bracket expression.
***	A->a, A->b, A->c
***	A->[abc], A->[a-z]   Syntactic sugar for the above.
***	NDFA gen:
****	For each production of the form A->[abc], generate an arc from A to Z which consumes a, b, or c
****	For each production of the form a->[a-b], generate an arc from A to Z which consumes a nonterminal in the range of a-b
****	For each production of the form A->[abc]B, generate an arc from A to B which consumes a, b, or c
****	For each production of the form a->[a-b]B, generate an arc from A to B which consumes a nonterminal in the range of a-b


**	[^abc],[^a-z]  Negated Bracket expression.
***	A->d, A->e, A->f, A->g, ...
***	A->[^abc], A->[^a-z]   Syntactic sugar for the above.
****	For each production of the form A->[^abc], generate an arc from A to Z which consumes anything but a, b, or c
****	For each production of the form a->[^a-b], generate an arc from A to Z which consumes a terminal not in the range of a-b
****	For each production of the form A->[^abc]B, generate an arc from A to B which consumes any temrinal  but a, b, or c
****	For each production of the form a->[a-b]B, generate an arc from A to B which consumes any terminal but a terminal in the range of a-b


**	^  Match beginning of line
***	honetsly, I don't know how to do this
***	but I'm guessing A->^, A->^B would work just fine...
***	NDFA gen:
****	well an easy thing to say would be treat the beginning of the line as a pseudo-nonterminal,
****	for each production of the form A->^, add an arc from A to Z which consumes the pseudo-nonterminal ^
****	for each production of the form A->^B, add an arc from A to B which consumes the pseudo-nonterminal ^

**	$  Match beginning of line
***	honetsly, I don't know how to do this
***	but I'm guessing A->$, A->$B would work just fine...
***	NDFA gen:
****	well an easy thing to say would be treat the end of the line as a pseudo-nonterminal,
****	for each production of the form A->$, add an arc from A to Z which consumes the pseudo-nonterminal $
****	for each production of the form A->$B, add an arc from A to B which consumes the pseudo-nonterminal $


**	* match preceeding element zero or more times
***	Say E is what we want to match zero or more times.
****	NDFA gen:
*****	must look up how standard re parsers do it.

**	+ match preceeding element zero or more times
***	Say E is what we want to match zero or more times.
****	NDFA gen:
*****	must look up how standard re parsers do it.



*	some language studies


**	fun (a,b,c) { }

**	fun x.foo(a,b,c) {}

**	fun as a prefix binary or prefix ternary operator?


**	what if each function had a self which refered to its scope?
***	i think it could probably work.  need to dork it tho.


**	{  print("h w")  ; x=y+5 }

***	function names as prefix operators?
	
****	fun xshift(x y) { x += 5 return (x,y) }

****	() as tuple operator?
	
	(x y) =  xshift(x y)
	
	man I really want to type a ,
	
	fun xshift x,y  { x+=5 return x,y }
	
	while x<5 {
	      print(x)
	      x = x - 1
	}
		
	for i=0,i<5,i++ {
	}
	
	arr = [0 -> w, x,  y,  z,  "a" -> "b",  "a" => "b",  "c" => "d", ]
 	
	arr.0 == x
	arr.a == "b"
	
	0.5 double
	0..5 decimal
	
	5..0


*	operators
	
**	, tuple operator
	
**      . decimal
	
**	..decimal

A -> 'a',B

hmmm........ that might actually not be so bad lol

But really, it is a ternary operator.  And the parse tree should reflect that.
	

*	Self-reflective grammar



*       T

**      T   -->  '\'' T1
***     T1  -->  'X'T2  where X in [a-zA-Z]
***     T2  -->  'X'T2  where X in [_0-9a-zA-Z]
***     T2  -->  '\''

**	T   --> '[' T3
***	T3  --> 'X' T4  where X in [_0-9a-zA-Z]
***	T4  --> 

*	NT

**	NT  -->  [a-zA-z] NT1
**      NT1 -->  [a-zA-z_1-9] NT2

