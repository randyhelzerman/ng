*	regular grammars
**	A ->,  A->a, A->aB,  distinguished S symbol

* 	translating them to NDFAs

**	One state for each of the nonterminals

**	S for initial state, new state Z for final state

**	Each production of the form A->a generates an arc from A to Z, which consumes a

**	Each production of the form A->aB generates an arc from A to B, which consumes a

**	Each production of the form A-> generates an arc from A to Z, which doesn't consume anything.


*	Example Regular expressions and how to do them

**	.  Any single character

***	A->a1,  A->a2, ....  A->a1B, A->a2B, ....

***	Obvious fix:

***	A->., A->.B  Syntactic Sutar for the above.

***	NDFA gen:
****	For each production of the form A->., generate an arc from A to Z, which consumes any single terminal
****	For each production of the form A->.B, generate an arc from A to B, which consumes any single terminal


**	[abc],[a-z]  Bracket expression.
***	A->a, A->b, A->c
***	A->[abc], A->[a-z]   Syntactic sugar for the above.
***	NDFA gen:
****	For each production of the form A->[abc], generate an arc from A to Z which consumes a, b, or c
****	For each production of the form a->[a-b], generate an arc from A to Z which consumes a nonterminal in the range of a-b
****	For each production of the form A->[abc]B, generate an arc from A to B which consumes a, b, or c
****	For each production of the form a->[a-b]B, generate an arc from A to B which consumes a nonterminal in the range of a-b


**	[^abc],[^a-z]  Negated Bracket expression.
***	A->d, A->e, A->f, A->g, ...
***	A->[^abc], A->[^a-z]   Syntactic sugar for the above.
****	For each production of the form A->[^abc], generate an arc from A to Z which consumes anything but a, b, or c
****	For each production of the form a->[^a-b], generate an arc from A to Z which consumes a terminal not in the range of a-b
****	For each production of the form A->[^abc]B, generate an arc from A to B which consumes any temrinal  but a, b, or c
****	For each production of the form a->[a-b]B, generate an arc from A to B which consumes any terminal but a terminal in the range of a-b


**	^  Match beginning of line
***	honetsly, I don't know how to do this
***	but I'm guessing A->^, A->^B would work just fine...
***	NDFA gen:
****	well an easy thing to say would be treat the beginning of the line as a pseudo-nonterminal,
****	for each production of the form A->^, add an arc from A to Z which consumes the pseudo-nonterminal ^
****	for each production of the form A->^B, add an arc from A to B which consumes the pseudo-nonterminal ^

**	$  Match beginning of line
***	honetsly, I don't know how to do this
***	but I'm guessing A->$, A->$B would work just fine...
***	NDFA gen:
****	well an easy thing to say would be treat the end of the line as a pseudo-nonterminal,
****	for each production of the form A->$, add an arc from A to Z which consumes the pseudo-nonterminal $
****	for each production of the form A->$B, add an arc from A to B which consumes the pseudo-nonterminal $


**	* match preceeding element zero or more times
***	Say E is what we want to match zero or more times.
****	NDFA gen:
*****	must look up how standard re parsers do it.

**	+ match preceeding element zero or more times
***	Say E is what we want to match zero or more times.
****	NDFA gen:
*****	must look up how standard re parsers do it.

